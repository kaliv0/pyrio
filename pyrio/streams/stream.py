from __future__ import annotations
from typing import Any, Callable, Iterable, TypeVar, Self

from pyrio.decorators import pre_call, handle_consumed
from pyrio.streams import BaseStream
from pyrio.iterators import StreamGenerator, ItertoolsMixin
from pyrio.utils import Optional

T = TypeVar("T")


@pre_call(handle_consumed)
class Stream(BaseStream, ItertoolsMixin):
    """Abstraction over a sequence of elements supporting sequential aggregate operations"""

    @classmethod
    def of(cls, *iterable: Any) -> Self:
        """Creates Stream from args"""
        return cls(iterable)

    @classmethod
    def of_nullable(cls, iterable: Iterable[Any] | None) -> Stream:
        """Creates Stream from args if iterable is not None; otherwise returns empty Stream"""
        if iterable is None:
            return cls.empty()
        return cls(iterable)

    @classmethod
    def empty(cls) -> Stream:
        """Creates empty Stream"""
        return cls([])

    @classmethod
    def iterate(
        cls,
        seed: Any,
        operation: Callable[[Any], Any],
        condition: Callable[[Any], bool] | None = None,
    ) -> Stream:
        """Creates infinite ordered Stream"""
        return cls(StreamGenerator.iterate(seed, operation, condition))

    @classmethod
    def generate(cls, supplier: Callable[[], Any]) -> Stream:
        """Creates infinite unordered Stream with values generated by given supplier function"""
        return cls(StreamGenerator.generate(supplier))

    @classmethod
    def constant(cls, element: Any) -> Stream:
        """Creates infinite Stream with given value"""
        return cls.generate(lambda: element)

    @classmethod
    def from_range(cls, start: int, stop: int, step: int = 1):
        """Creates Stream from start (inclusive) to stop (exclusive) by an incremental step"""
        return cls(StreamGenerator.range(start, stop, step))  # type: ignore[arg-type]

    # NB: handle_consumed decorator needs access to toggle flag
    def take_nth(self, idx: int, default: Any = None) -> Optional:
        """Returns Optional with the nth element of the stream or a default value"""
        return super().take_nth(idx, default)

    def all_equal(self, key: Callable[[Any], Any] | None = None) -> bool:
        """Returns True if all elements of the stream are equal to each other"""
        return super().all_equal(key)
